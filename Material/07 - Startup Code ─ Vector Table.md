07 - Startup Code ─ Vector Table
===

In this lecture, we will discuss exceptions in the Cortex-M processor, and complete the vector table for the startup code.

Additionally, we will implement an external interrupt with the user button on STM32F4DISCOVERY board.

**<p style="color:crimson"><i class="fa fa-github"></i> Please fork the [LAB07](https://github.com/ybcsie/ESEmbedded_LAB07) repo, and then clone the repo you just forked.</p>**

**<p style="color:crimson">　 You will have to push the modified version to GitHub at the end of this lecture.</p>**

---

## Exceptions and Interrupts

* Interrupts are events typically generated by hardware (e.g., peripherals or external input pins) that cause changes in program flow control outside a normal programmed sequence (e.g., to provide service to a peripheral).

* When a peripheral or hardware needs service from the processor, typically the following sequence would occur:
    1. The peripheral asserts an interrupt request to the processor
    2. The processor suspends the currently executing task
    3. The processor executes an Interrupt Service Routine (ISR) to service the peripheral, and optionally clear the interrupt request by software if needed
    4. The processor resumes the previously suspended task

* All Cortex-M processors provide a Nested Vectored Interrupt Controller (NVIC) for interrupt handling.

* There are other events that need servicing and we called them "**exceptions**". An interrupt is one type of exception.

* The pieces of program code that handle exceptions are often called exception handlers. They are part of the compiled program image.

* In a typical Cortex-M microcontroller, the NVIC receives interrupt requests from various sources, as shown in the following figure.

    ![](http://125.227.181.237/uploads/upload_8326a4a758e7b7477de3126b586b9660.png)

* In order to resume the interrupted program, the exception sequence needs some way to **store the status of the interrupted program** so that this can be restored after the exception handler is completed.

* In the Cortex-M processors, some of the registers are saved onto the stack automatically when an exception is accepted, and are also automatically restored in an exception return sequence.

* This mechanism allows the exception handlers to be written as normal C functions without any additional software overhead. (We will discuss this later.)

### List of System Exceptions

![](http://125.227.181.237/uploads/upload_787d0e33b437f5302c8bc20f93633dc4.png)

#### NMI in STM32F407

* According to [*RM0090 Reference manual STM32F407*], the NMI is linked to the clock security system.

    ![](http://125.227.181.237/uploads/upload_e915b3abb89ad3dcd60525c87dcdad67.png)

### List of Interrupts

![](http://125.227.181.237/uploads/upload_3b27ff81320f8516db0ba376c8e5ffe9.png)



### Vector Table

* When an exception occurs, the processor will need to locate the starting point of the corresponding exception handler.

* Traditionally, in ARM processors such as the ARM7TDMI, software handles this step.

* The Cortex-M processors automatically locate the starting point of the exception handler from a vector table in the memory.

* As a result, the delays from the start of the exception to the execution of the exception handlers are reduced.

* The LSB of each exception vector indicates whether the exception is to be executed in the Thumb state. Since the Cortex-M processors can support only Thumb instructions, the LSB of all the exception vectors should be set to 1.

![](http://125.227.181.237/uploads/upload_379097a7a5c4f7dac22038eb8e37ab7f.png)


### Fault Handling

* Fault exceptions are triggered when the processor detects an error such as the execution of an undefined instruction, or when the bus system returns an error response to a memory access.

* By default the Bus Fault, Usage Fault, and Memory Management Fault are disabled and all fault events trigger the HardFault exception.

* The configurations are programmable and you can enable the three programmable fault exceptions individually to handle different types of faults.

* The HardFault exception is always enabled.

![](http://125.227.181.237/uploads/upload_9cab1725813291013767390e89dd0df5.png)



---------------------------------------------------------------------------------------------------------------------------------



## LAB07-1 Hardfault Exception: Execute from XN

**<p style="color:crimson"><i class="fa fa-folder" style="color:orange"></i> The lab files are in `ESEmbedded_LAB07/1_hardfault_xn`</p>**

* In [*ARM®v7-M Architecture Reference Manual*] ─ *B3.1 The system address map*, you can find out the Execute Never (XN) regions. Any attempt to execute code from an XN region faults, generating a MemManage exception.

    ![](http://125.227.181.237/uploads/upload_d46286e8fde4dadf9082901b1c2eeeec.png)

* We are going to implement the hard fault exeception handler, and try to execute from `0x40000000`.

### Source Code

#### <i class="fa fa-file-code-o" style="color:gray"></i> vector_table.s

```=
.section .vector_table

.word _msp_init
.word reset_handler
.word nmi_handler
.word hardfault_handler
```

#### <i class="fa fa-file-code-o" style="color:gray"></i> startup.c

```clike=
#include <stdint.h>
#include "reg.h"
#include "blink.h"

void set_sysclk_pll(void);

void reset_handler(void)
{
	//symbols defined in linker script
	extern uint32_t _mydata_lma_start;
	extern uint32_t _mydata_vma_start;
	extern uint32_t _mydata_vma_end;
	extern uint32_t _mybss_vma_start;
	extern uint32_t _mybss_vma_end;
	//note that for the variables above, "symbol value" is equivalent to the address we want
	//use "&" operator to get symbol values

	uint32_t *mydata_lstart_ptr = &_mydata_lma_start;
	uint32_t *mydata_vstart_ptr = &_mydata_vma_start;
	uint32_t *mydata_vend_ptr = &_mydata_vma_end;

	uint32_t *mybss_vstart_ptr = &_mybss_vma_start;
	uint32_t *mybss_vend_ptr = &_mybss_vma_end;

	uint32_t *src_ptr, *dst_ptr;

	src_ptr = mydata_lstart_ptr;
	dst_ptr = mydata_vstart_ptr;

	while (dst_ptr < mydata_vend_ptr)
		*dst_ptr++ = *src_ptr++;

	dst_ptr = mybss_vstart_ptr;

	while (dst_ptr < mybss_vend_ptr)
		*dst_ptr++ = 0;

	set_sysclk_pll();

	// test hardfault
	blink_count(LED_BLUE, 20);

	// execute from 0x40000000
	??????

	blink(LED_BLUE);
}

void nmi_handler(void)
{
	while (1)
		;
}

void hardfault_handler(void)
{
	blink(LED_RED);
}

/**
 * 
 * set sysclk pll (168 MHz)
 * 
 */
void set_sysclk_pll(void)
{
	//enable HSE
	SET_BIT(RCC_BASE + RCC_CR_OFFSET, HSEON_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CR_OFFSET, HSERDY_BIT) != 1)
		;

	//set pll
	SET_BIT(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLSRC_BIT); //use HSE for PLL source

	//f_HSE = 8 MHz
	//
	//N = 168
	//M = 4
	//
	//f_VCO = 8 * 168 / 4 = 168 * 2
	//
	//P = 2
	//
	//f_PLL_out = 168
	//
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLP_1_BIT, PLLP_0_BIT, 0b00);
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLN_8_BIT, PLLN_0_BIT, 168);
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLM_5_BIT, PLLM_0_BIT, 4);

	//enable pll
	SET_BIT(RCC_BASE + RCC_CR_OFFSET, PLLON_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CR_OFFSET, PLLRDY_BIT) != 1)
		;

	//enable flash prefetch buffer
	SET_BIT(FLASH_BASE + FLASH_ACR_OFFSET, PRFTEN_BIT);

	//set flash wait state = 5
	WRITE_BITS(FLASH_BASE + FLASH_ACR_OFFSET, LATENCY_2_BIT, LATENCY_0_BIT, 5);

	//use pll
	SET_BIT(RCC_BASE + RCC_CFGR_OFFSET, SW_1_BIT);
	CLEAR_BIT(RCC_BASE + RCC_CFGR_OFFSET, SW_0_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CFGR_OFFSET, SWS_1_BIT) != 1 || READ_BIT(RCC_BASE + RCC_CFGR_OFFSET, SWS_0_BIT) != 0)
		;
}
```

#### <i class="fa fa-file-code-o" style="color:gray"></i> reg.h

```clike=
#ifndef REG_H
#define REG_H

//REG OPERATIONS
#define UINT32_1 ((uint32_t)1)

#define REG(addr) (*((volatile uint32_t *)(addr)))

#define CLEAR_MASK(highest_bit, lowest_bit) (((highest_bit) - (lowest_bit)) >= 31 ? (uint32_t)0xFFFFFFFF : ~(((UINT32_1 << ((highest_bit) - (lowest_bit) + 1)) - 1) << (lowest_bit)))
#define WRITE_BITS(addr, highest_bit, lowest_bit, data) (REG(addr) = (REG(addr) & CLEAR_MASK(highest_bit, lowest_bit)) | ((uint32_t)(data) << (lowest_bit)))

#define SET_BIT(addr, bit) (REG(addr) |= UINT32_1 << (bit))
#define CLEAR_BIT(addr, bit) (REG(addr) &= ~(UINT32_1 << (bit)))

#define READ_BIT(addr, bit) ((REG(addr) >> (bit)) & UINT32_1)

//FLASH
#define FLASH_BASE 0x40023C00

#define FLASH_ACR_OFFSET 0x00
#define PRFTEN_BIT 8
#define LATENCY_2_BIT 2
#define LATENCY_0_BIT 0

//RCC
#define RCC_BASE 0x40023800

#define RCC_CR_OFFSET 0x00
#define PLLRDY_BIT 25
#define PLLON_BIT 24
#define HSERDY_BIT 17
#define HSEON_BIT 16

#define RCC_PLLCFGR_OFFSET 0x04

#define PLLSRC_BIT 22

#define PLLP_1_BIT 17
#define PLLP_0_BIT 16

#define PLLN_8_BIT 14
#define PLLN_0_BIT 6

#define PLLM_5_BIT 5
#define PLLM_0_BIT 0

#define RCC_CFGR_OFFSET 0x08
#define MCO2_1_BIT 31
#define MCO2_0_BIT 30

#define MCO2PRE_2_BIT 29
#define MCO2PRE_0_BIT 27

#define SWS_1_BIT 3
#define SWS_0_BIT 2

#define SW_1_BIT 1
#define SW_0_BIT 0

#define RCC_AHB1ENR_OFFSET 0x30
#define GPIO_EN_BIT(port) (port)

//GPIO
#define GPIO_PORTA 0
#define GPIO_PORTB 1
#define GPIO_PORTC 2
#define GPIO_PORTD 3

#define GPIO_BASE(port) (0x40020000 + 0x400 * (port))

#define GPIOx_MODER_OFFSET 0x00
#define MODERy_1_BIT(y) ((y)*2 + 1)
#define MODERy_0_BIT(y) ((y)*2)

#define GPIOx_OTYPER_OFFSET 0x04
#define OTy_BIT(y) (y)

#define GPIOx_OSPEEDR_OFFSET 0x08
#define OSPEEDRy_1_BIT(y) ((y)*2 + 1)
#define OSPEEDRy_0_BIT(y) ((y)*2)

#define GPIOx_PUPDR_OFFSET 0x0C
#define PUPDRy_1_BIT(y) ((y)*2 + 1)
#define PUPDRy_0_BIT(y) ((y)*2)

#define GPIOx_BSRR_OFFSET 0x18
#define BRy_BIT(y) ((y) + 16)
#define BSy_BIT(y) (y)

#endif
```

#### <i class="fa fa-file-code-o" style="color:gray"></i> blink.h

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-blinkh)

#### <i class="fa fa-file-code-o" style="color:gray"></i> blink.c

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-blinkc1)

### Linker Script

#### <i class="fa fa-file-text-o" style="color:gray"></i> stm32f4.ld

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-stm32f4ld)

### Makefile

#### <i class="fa fa-file-text-o" style="color:gray"></i> makefile

```makefile=
CROSS-COMPILER = arm-none-eabi-

all: hardfault.bin

hardfault.bin: blink.c startup.c vector_table.s
	$(CROSS-COMPILER)gcc -std=c11 -Wall -mcpu=cortex-m4 -mthumb -nostartfiles -T stm32f4.ld blink.c startup.c vector_table.s -o hardfault.elf
	$(CROSS-COMPILER)objcopy -O binary hardfault.elf hardfault.bin

flash:
	st-flash --reset write hardfault.bin 0x8000000

clean:
	rm -f *.o *.elf *.bin
```

### Build

1. Generate the .bin file with

    ```shell
    make
    ```

2. Connect your STM32F4DISCOVERY board, and flash by

    ```shell
    make flash
    ```



---------------------------------------------------------------------------------------------------------------------------------------




## Exception Handling in Detail

* We mentioned that with the Cortex-M processor, you can program your exception handlers or Interrupt Service Routines (ISR) as normal C routines/functions.

* In order to understand the exact mechanism to support this, we first look at how C functions work on ARM architecture.

### Calling Convention ─ AAPCS

* C compilers for ARM architecture follow a specification from ARM called the **AAPCS**, Procedure Call Standard for ARM Architecture.

* According to this standard, **a C function can modify R0 to R3, R12, R14 (LR), and PSR**.

* **R0~R3, R12, LR, and PSR are called “caller saved registers”**. The program code that calls a subroutine needs to save these register contents into memory (e.g., stack) before the function call if these values will still be needed after the function call.

* **R4~R11 are called “callee-saved registers”**. The subroutine or function being called needs to make sure the contents of these registers are unaltered at the end of the function (same value as when the function is entered).

* If the C function needs **to use R4 to R11, it should save these registers on to the stack memory and restore them before the end of the function**.

* Typically, a function call uses R0 to R3 as input parameters, and R0 as the return result. If the return value is 64 bits, R1 will also be used as the return result

![](http://125.227.181.237/uploads/upload_fbc71e27d39b2c226331ce8e4705dde1.png)

#### Function Call Sequences Example

![](http://125.227.181.237/uploads/upload_842a9b6f0995894d2f5e3378da3c23d5.png)



### Hardware Mechanism

* In order to allow a C function to be used as an exception handler, the exception mechanism needs to **save R0 to R3, R12, LR, and PSR at exception entrance automatically, and restore them at exception exit** under the control of the processor’s hardware.

* In this way when returned to the interrupted program, all the registers would have the same value as when the interrupt entry sequence started.

#### Stack Frames

* The block of data that are pushed to the stack memory at exception entrance is called a stack frame.

* For the Cortex-M3 processor or Cortex-M4 processor without the floating point unit, the stack frames are always eight words.

    ![](http://125.227.181.237/uploads/upload_e4a58163d0da08bb070a00f90094b257.png)

* If the double-word stack alignment feature was enabled (enable by default), and the value of the stack pointer was not aligned to double-word boundary, then:

    1. a padding spaces is inserted to the stack to force the stack pointer to be aligned to double-word location

    2. bit9 of the stacked xPSR is set to 1, to indicate the present of the padding space

    ![](http://125.227.181.237/uploads/upload_6a6daabf788ca01c6d4da33780d98bea.png)

* For Cortex-M4 with floating point unit, if the floating point unit has been enabled and used, the stack frame will include S0 to S15 of the registers in the floating point unit register bank.

    ![](http://125.227.181.237/uploads/upload_1b93ba6204fa95b853bafc64ab640382.png)

#### EXC_RETURN

* As the processor enters the exception handler or Interrupt Service Routine (ISR), the value of the Link Register (LR) is updated to a code called EXC_RETURN.

* The value of this code is used to trigger the exception return mechanism when it is loaded into the PC.

* The definition of the EXC_RETURN value is shown below.

    ![](http://125.227.181.237/uploads/upload_72a12469dbf378ea773c9135667449f4.png)

* The valid values of the EXC_RETURN value is shown below.

    ![](http://125.227.181.237/uploads/upload_b8fafa305b08ce44cd1673cd780175a5.png)

#### Exception Sequences Example

![](http://125.227.181.237/uploads/upload_bb0b31280982dc9138d7cfc1109f7bac.png)


---------------------------------------------------------------------------------------------------------------------------------



## LAB07-2 Hardfault Exception: Switch into ARM State

**<p style="color:crimson"><i class="fa fa-folder" style="color:orange"></i> The lab files are in `ESEmbedded_LAB07/2_hardfault_state`</p>**

* Since the Cortex-M processors can support only Thumb instructions, hardfault exception will defaultly be triggered if the processor state is switched into ARM state.

* We are going to implement it with simple assembly code and observe the hardware exception mechanism with GDB.

### Source Code

#### <i class="fa fa-file-code-o" style="color:gray"></i> hardfault.s

```=
.section .vecter_table

.word _msp_init
.word reset_handler
.word nmi_handler
.word hardfault_handler

.section .text

.syntax unified


loop:
	b	.;


init_regs:
	movs	R0,	#0xA0;
	movs	R1,	#0xA1;
	movs	R2,	#0xA2;
	movs	R3,	#0xA3;
	movs	R4,	#0xA4;
	movs	R5,	#0xA5;
	movs	R6,	#0xA6;
	movs	R7,	#0xA7;
	movs	R8,	#0xA8;
	movs	R8,	#0xA8;
	movs	R9,	#0xA9;
	movs	R10,	#0xAA;
	movs	R11,	#0xAB;
	movs	R12,	#0xAC;
	blx	loop;

.type	reset_handler, %function
reset_handler:
	b	init_regs;


.type	nmi_handler, %function
nmi_handler:
	b	.


.type	hardfault_handler, %function
hardfault_handler:
	movs	R0,	#0;
	movs	R1,	#0;
	movs	R2,	#0;
	movs	R3,	#0;
	movs	R4,	#0;
	movs	R5,	#0;
	movs	R6,	#0;
	movs	R7,	#0;
	movs	R8,	#0;
	movs	R8,	#0;
	movs	R9,	#0;
	movs	R10,	#0;
	movs	R11,	#0;
	movs	R12,	#0;
	bx	lr;

```

### Linker Script

#### <i class="fa fa-file-text-o" style="color:gray"></i> stm32f4.ld

```=
MEMORY
{
	FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 1M
	SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
}

SECTIONS
{
	.mytext :
	{
		KEEP(*(.vecter_table))
		*(.text)
	} > FLASH

	_msp_init = ORIGIN(SRAM) + LENGTH(SRAM);
}
```

### Makefile

#### <i class="fa fa-file-text-o" style="color:gray"></i> makefile

```makefile=
CROSS-COMPILER = arm-none-eabi-

all: hardfault.bin

hardfault.bin: hardfault.s
	$(CROSS-COMPILER)gcc -std=c11 -Wall -mcpu=cortex-m4 -mthumb -nostartfiles -T stm32f4.ld hardfault.s -o hardfault.elf
	$(CROSS-COMPILER)objcopy -O binary hardfault.elf hardfault.bin

flash:
	st-flash --reset write hardfault.bin 0x8000000

clean:
	rm -f *.o *.elf *.bin
```

### Build

1. Generate the .bin file with

    ```shell
    make
    ```

2. Connect your STM32F4DISCOVERY board, and flash by

    ```shell
    make flash
    ```

### Varify with GDB

1.  Start the ST-Link GDB server:

    ```shell
    st-util -p 1234
    ```

1. Open a new terminal window, and start GDB:

    ````shell
    arm-none-eabi-gdb
    ````

1. Connet to stlink gdb server:

    ````shell
    target remote localhost:1234
    ````
1. Press (ctrl + x) and then press (2) for 2 times to show register contents.

1. Execute a step:

    ````shell
    si
    ````

1. Keep pressing ENTER to execute next steps.

1. Dump stack:

    ````shell
    x $sp
    ````

1. Keep pressing ENTER to dump more.

:::success

**The stack is empty before the exception is triggered:**

![](http://125.227.181.237/uploads/upload_463e4ce3c17c0172c1222481ce4e8a3b.png)

:::

:::success

**The stack frame is saved by the hardware:**

![](http://125.227.181.237/uploads/upload_17bae6b04d9dd301a0692bde5e39c85b.png)

:::

:::success

**The register contents are changed by the exception handler:**

![](http://125.227.181.237/uploads/upload_4a60b4e02b0b57aac8912661c7d15e32.png)

:::

:::success

**The register contents are restored from the stack frame by the hardware:**

![](http://125.227.181.237/uploads/upload_53a1e7814ae616ce93ddb5db24eaa5cf.png)

:::


---------------------------------------------------------------------------------------------------------



## LAB07-3 External Interupt (EXTI)

* In this lab, we are going to use the user button to send the external interrupt to the STM32F407 mcu.

* We will make the interrupt handler blink another led for several times and then return to the original blink loop.

### Push Buttons on STM32F4DISCOVERY

* According to [*UM1472 User manual Discovery kit with STM32F407VG MCU*], the user button (the blue one) is connected to the I/O PA0 of the mcu.

    ![](http://125.227.181.237/uploads/upload_02d7f145563c01e8cc79edcb3031266f.png)

* Electrical schematic of peripherals:

    ![](http://125.227.181.237/uploads/upload_70867ecf2f9d6a0e2f6ef27aa09dc6fc.png)

* To make this button work, you have to:
    1. Enable GPIOA in RCC
    2. Configure PA0 as input without pull-up or pull-down in GPIO registers

* See [Simple Program ─ Blink in Lecture 04] or [*RM0090 Reference manual STM32F407*] for details.

### External Interrupt Controller (EXTI)

* The interrupt descriptions of STM32F407 microcontrollers are in [*RM0090 Reference manual STM32F407*] ─ *12.2 External interrupt/event controller (EXTI)*.

* The external interrupt/event controller consists of up to 23 edge detectors for generating interrupt requests.

* Each input line can be independently configured to select the corresponding trigger event (rising or falling or both).

* Each line can also masked independently.

* A pending register maintains the status line of the interrupt requests.

* In [*RM0090 Reference manual STM32F407*] ─ *12.2.5 External interrupt/event line mapping*, we can see the pin selections are controlled by SYSCFG external interrupt configuration register (**SYSCFG_EXTICR1~SYSCFG_EXTICR4**)

    ![mux](http://125.227.181.237/uploads/upload_ba276ca1bdca5a1fc35af83a86a6a8d6.png)

#### Vector Table for STM32F405xx/07xx and STM32F415xx/17xx

![](http://125.227.181.237/uploads/upload_ea6d69c5a7f5aeb8a2c22ffa034375b4.png)

※ The position number is the interrupt number controlled by NVIC.

* To generate the interrupt, the interrupt line should be configured and enabled. This is done by:
    1. Programming the two trigger registers (**EXTI_RTSR and EXTI_FTSR**) with the desired edge detection
    2. Enabling the interrupt request by writing a ‘1’ to the corresponding bit in the interrupt mask register (**EXTI_IMR**)
    3. Configuring the related **NVIC registers** ([*ARM®v7-M Architecture Reference Manual*] ─ *B3.4 Nested Vectored Interrupt Controller, NVIC*)

* When the interrupt request is generated, **the pending bit corresponding to the interrupt line is also set**, and **this request is reset by writing a ‘1’ in the pending register** (**EXTI_PR**).

![EXTI_IMR](http://125.227.181.237/uploads/upload_852721599679c8343cbee9d6f484978b.png)

![EXTI_RTSR & EXTI_FTSR](http://125.227.181.237/uploads/upload_e8c66b3ea6328f82e67c4bec5a86197a.png)

![EXTI_PR](http://125.227.181.237/uploads/upload_f9276f291a53d1ffd813389ae38ca407.png)


### System Configuration Controller (SYSCFG)

* The system configuration controller is mainly used to:
    1. Remap the memory accessible in the code area
    2. Select the Ethernet PHY interface
    3. Manage the external interrupt line connection to the GPIOs

* We need to configure SYSCFG_EXTICR1, and **remember to enable SYSCFG in RCC** ([*RM0090 Reference manual STM32F407*] ─ *6.3.14 RCC APB2 peripheral clock enable register (RCC_APB2ENR)*).

    ![SYSCFG_EXTICR1](http://125.227.181.237/uploads/upload_2bf9e3f89e89d3b245c1bf135082f133.png)

### Nested Vectored Interrupt Controller, NVIC

* Since NVIC is a portion of a ARM Cortex-M processor, NVIC registers are described in [*ARM®v7-M Architecture Reference Manual*].

* Here we just enable the interrupt we want. If you are interested in other features, see [*ARM®v7-M Architecture Reference Manual*] ─ *B3.4 Nested Vectored Interrupt Controller, NVIC* for more information.

* NVIC interrupts can be enabled and disabled by writing to their corresponding **Interrupt Set-Enable** or Interrupt Clear-Enable register bit field.

    ![](http://125.227.181.237/uploads/upload_8b2df15c1daaa683e40a5000b92da8ba.png)

    ![](http://125.227.181.237/uploads/upload_5f615d281f75dc8a2c17777498634f3e.png)

* Accordingly, **to enable the IRQ6, we will write 1 to the bit 6 of NVIC_ISER0**.

* **The pending bit does not have to be cleared by the software manually** because the hardware will do it. See the following pseudocode:

    ![](http://125.227.181.237/uploads/upload_c72803f3e963be6b5911b2007aec420d.png)

### Source Code

:::warning

Try to modify `main.c`

:::

#### <i class="fa fa-file-code-o" style="color:gray"></i> vector_table.s

```=
.section .vector_table

.word _msp_init
.word reset_handler

/*********************************************************/

.weak	nmi_handler
.thumb_set	nmi_handler,default_handler
.word nmi_handler

/*********************************************************/

.weak	hardfault_handler
.thumb_set	hardfault_handler,default_handler
.word hardfault_handler

/*********************************************************/

.weak	mmfault_handler
.thumb_set	mmfault_handler,default_handler
.word mmfault_handler

/*********************************************************/

.weak	busfault_handler
.thumb_set	busfault_handler,default_handler
.word busfault_handler

/*********************************************************/

.weak	usagefault_handler
.thumb_set	usagefault_handler,default_handler
.word usagefault_handler

/*********************************************************/

.word 0 //reserved
.word 0 //reserved
.word 0 //reserved
.word 0 //reserved

/*********************************************************/

.weak	svc_handler
.thumb_set	svc_handler,default_handler
.word svc_handler

/*********************************************************/

.weak	debugmonitor_handler
.thumb_set	debugmonitor_handler,default_handler
.word debugmonitor_handler

/*********************************************************/

.word 0 //reserved

/*********************************************************/

.weak	pendsv_handler
.thumb_set	pendsv_handler,default_handler
.word pendsv_handler

/*********************************************************/

.weak	systick_handler
.thumb_set	systick_handler,default_handler
.word systick_handler

/*********************************************************/

.weak	wwdg_handler
.thumb_set	wwdg_handler,default_handler
.word wwdg_handler

/*********************************************************/

.weak	pvd_handler
.thumb_set	pvd_handler,default_handler
.word pvd_handler

/*********************************************************/

.weak	tamp_stamp_handler
.thumb_set	tamp_stamp_handler,default_handler
.word tamp_stamp_handler

/*********************************************************/

.weak	rtc_wkup_handler
.thumb_set	rtc_wkup_handler,default_handler
.word rtc_wkup_handler

/*********************************************************/

.weak	flash_handler
.thumb_set	flash_handler,default_handler
.word flash_handler

/*********************************************************/

.weak	rcc_handler
.thumb_set	rcc_handler,default_handler
.word rcc_handler

/*********************************************************/

.weak	exti0_handler
.thumb_set	exti0_handler,default_handler
.word exti0_handler


．．．．．．


//////////////////////////////////////////////////////////

.syntax unified

.type	default_handler, %function
default_handler:
	b	.

```

#### <i class="fa fa-file-code-o" style="color:gray"></i> startup.c

```clike=
#include <stdint.h>
#include "blink.h"
#include "reg.h"

extern int main(void);

void set_sysclk_pll(void);

void reset_handler(void)
{
	//symbols defined in linker script
	extern uint32_t _mydata_lma_start;
	extern uint32_t _mydata_vma_start;
	extern uint32_t _mydata_vma_end;
	extern uint32_t _mybss_vma_start;
	extern uint32_t _mybss_vma_end;
	//note that for the variables above, "symbol value" is equivalent to the address we want
	//use "&" operator to get symbol values

	uint32_t *mydata_lstart_ptr = &_mydata_lma_start;
	uint32_t *mydata_vstart_ptr = &_mydata_vma_start;
	uint32_t *mydata_vend_ptr = &_mydata_vma_end;

	uint32_t *mybss_vstart_ptr = &_mybss_vma_start;
	uint32_t *mybss_vend_ptr = &_mybss_vma_end;

	uint32_t *src_ptr, *dst_ptr;

	src_ptr = mydata_lstart_ptr;
	dst_ptr = mydata_vstart_ptr;

	while (dst_ptr < mydata_vend_ptr)
		*dst_ptr++ = *src_ptr++;

	dst_ptr = mybss_vstart_ptr;

	while (dst_ptr < mybss_vend_ptr)
		*dst_ptr++ = 0;

	set_sysclk_pll();

	main();

}

void hardfault_handler(void)
{
	blink(LED_RED);
}

/**
 * 
 * set sysclk pll (168 MHz)
 * 
 */
void set_sysclk_pll(void)
{
	//enable HSE
	SET_BIT(RCC_BASE + RCC_CR_OFFSET, HSEON_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CR_OFFSET, HSERDY_BIT) != 1)
		;

	//set pll
	SET_BIT(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLSRC_BIT); //use HSE for PLL source

	//f_HSE = 8 MHz
	//
	//N = 168
	//M = 4
	//
	//f_VCO = 8 * 168 / 4 = 168 * 2
	//
	//P = 2
	//
	//f_PLL_out = 168
	//
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLP_1_BIT, PLLP_0_BIT, 0b00);
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLN_8_BIT, PLLN_0_BIT, 168);
	WRITE_BITS(RCC_BASE + RCC_PLLCFGR_OFFSET, PLLM_5_BIT, PLLM_0_BIT, 4);

	//enable pll
	SET_BIT(RCC_BASE + RCC_CR_OFFSET, PLLON_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CR_OFFSET, PLLRDY_BIT) != 1)
		;

	//enable flash prefetch buffer
	SET_BIT(FLASH_BASE + FLASH_ACR_OFFSET, PRFTEN_BIT);

	//set flash wait state = 5
	WRITE_BITS(FLASH_BASE + FLASH_ACR_OFFSET, LATENCY_2_BIT, LATENCY_0_BIT, 5);

	//use pll
	SET_BIT(RCC_BASE + RCC_CFGR_OFFSET, SW_1_BIT);
	CLEAR_BIT(RCC_BASE + RCC_CFGR_OFFSET, SW_0_BIT);

	//wait
	while (READ_BIT(RCC_BASE + RCC_CFGR_OFFSET, SWS_1_BIT) != 1 || READ_BIT(RCC_BASE + RCC_CFGR_OFFSET, SWS_0_BIT) != 0)
		;
}
```

#### <i class="fa fa-file-code-o" style="color:gray"></i> main.c

```clike=
#include <stdint.h>
#include "reg.h"
#include "blink.h"

int main(void)
{
	//RCC Enable GPIOA
	??????

	//GPIO Configurations
	??????

	//RCC Enable SYSCFG
	??????

	//SYSCFG Configurations
	??????

	//EXTI Configurations
	??????

	//NVIC Configurations
	SET_BIT(NVIC_ISER_BASE + NVIC_ISERn_OFFSET(0), 6); //IRQ6

	blink(LED_BLUE);
}

void exti0_handler(void)
{
	blink_count(LED_ORANGE, 10);

	//clear pending
	SET_BIT(EXTI_BASE + EXTI_PR_OFFSET, 0);
}
```

#### <i class="fa fa-file-code-o" style="color:gray"></i> reg.h

```clike=
#ifndef REG_H
#define REG_H

//REG OPERATIONS
#define UINT32_1 ((uint32_t)1)

#define REG(addr) (*((volatile uint32_t *)(addr)))

#define CLEAR_MASK(highest_bit, lowest_bit) (((highest_bit) - (lowest_bit)) >= 31 ? (uint32_t)0xFFFFFFFF : ~(((UINT32_1 << ((highest_bit) - (lowest_bit) + 1)) - 1) << (lowest_bit)))
#define WRITE_BITS(addr, highest_bit, lowest_bit, data) (REG(addr) = (REG(addr) & CLEAR_MASK(highest_bit, lowest_bit)) | ((uint32_t)(data) << (lowest_bit)))

#define SET_BIT(addr, bit) (REG(addr) |= UINT32_1 << (bit))
#define CLEAR_BIT(addr, bit) (REG(addr) &= ~(UINT32_1 << (bit)))

#define READ_BIT(addr, bit) ((REG(addr) >> (bit)) & UINT32_1)

//FLASH
#define FLASH_BASE 0x40023C00

#define FLASH_ACR_OFFSET 0x00
#define PRFTEN_BIT 8
#define LATENCY_2_BIT 2
#define LATENCY_0_BIT 0

//RCC
#define RCC_BASE 0x40023800

#define RCC_CR_OFFSET 0x00
#define PLLRDY_BIT 25
#define PLLON_BIT 24
#define HSERDY_BIT 17
#define HSEON_BIT 16

#define RCC_PLLCFGR_OFFSET 0x04

#define PLLSRC_BIT 22

#define PLLP_1_BIT 17
#define PLLP_0_BIT 16

#define PLLN_8_BIT 14
#define PLLN_0_BIT 6

#define PLLM_5_BIT 5
#define PLLM_0_BIT 0

#define RCC_CFGR_OFFSET 0x08
#define MCO2_1_BIT 31
#define MCO2_0_BIT 30

#define MCO2PRE_2_BIT 29
#define MCO2PRE_0_BIT 27

#define SWS_1_BIT 3
#define SWS_0_BIT 2

#define SW_1_BIT 1
#define SW_0_BIT 0

#define RCC_AHB1ENR_OFFSET 0x30
#define GPIO_EN_BIT(port) (port)

#define RCC_APB2ENR_OFFSET 0x44
#define SYSCFGEN_BIT 14

//GPIO
#define GPIO_PORTA 0
#define GPIO_PORTB 1
#define GPIO_PORTC 2
#define GPIO_PORTD 3

#define GPIO_BASE(port) (0x40020000 + 0x400 * (port))

#define GPIOx_MODER_OFFSET 0x00
#define MODERy_1_BIT(y) ((y)*2 + 1)
#define MODERy_0_BIT(y) ((y)*2)

#define GPIOx_OTYPER_OFFSET 0x04
#define OTy_BIT(y) (y)

#define GPIOx_OSPEEDR_OFFSET 0x08
#define OSPEEDRy_1_BIT(y) ((y)*2 + 1)
#define OSPEEDRy_0_BIT(y) ((y)*2)

#define GPIOx_PUPDR_OFFSET 0x0C
#define PUPDRy_1_BIT(y) ((y)*2 + 1)
#define PUPDRy_0_BIT(y) ((y)*2)

#define GPIOx_BSRR_OFFSET 0x18
#define BRy_BIT(y) ((y) + 16)
#define BSy_BIT(y) (y)

//EXTI
#define EXTI_BASE 0x40013C00

#define EXTI_IMR_OFFSET 0x00

#define EXTI_RTSR_OFFSET 0x08

#define EXTI_FTSR_OFFSET 0x0C

#define EXTI_PR_OFFSET 0x14

//SYSCFG
#define SYSCFG_BASE 0x40013800

#define SYSCFG_EXTICR1_OFFSET 0x08

#define EXTI0_3_BIT 3
#define EXTI0_0_BIT 0

//NVIC
#define NVIC_ISER_BASE 0xE000E100

#define NVIC_ISERn_OFFSET(n) (0x00 + 4 * (n))

#endif
```


#### <i class="fa fa-file-code-o" style="color:gray"></i> blink.h

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-blinkh)

#### <i class="fa fa-file-code-o" style="color:gray"></i> blink.c

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-blinkc1)

### Linker Script

#### <i class="fa fa-file-text-o" style="color:gray"></i> stm32f4.ld

[**～～～**](http://www.nc.es.ncku.edu.tw/course/embedded/06/#-stm32f4ld)

### Makefile

#### <i class="fa fa-file-text-o" style="color:gray"></i> makefile

```makefile=
CROSS-COMPILER = arm-none-eabi-

all: exti.bin

exti.bin: main.c blink.c startup.c vector_table.s
	$(CROSS-COMPILER)gcc -std=c11 -Wall -mcpu=cortex-m4 -mthumb -nostartfiles -T stm32f4.ld main.c blink.c startup.c vector_table.s -o exti.elf
	$(CROSS-COMPILER)objcopy -O binary exti.elf exti.bin

flash:
	st-flash --reset write exti.bin 0x8000000

clean:
	rm -f *.o *.elf *.bin
```

### Build
1. Generate the .bin file with

    ```shell
    make
    ```

2. Connect your STM32F4DISCOVERY board, and flash by

    ```shell
    make flash
    ```

[*ARM®v7-M Architecture Reference Manual*]: http://www.nc.es.ncku.edu.tw/course/embedded/pdf/armv7m.pdf
[*RM0090 Reference manual STM32F407*]: http://www.nc.es.ncku.edu.tw/course/embedded/pdf/STM32F407_Reference_manual.pdf
[*UM1472 User manual Discovery kit with STM32F407VG MCU*]: http://www.nc.es.ncku.edu.tw/course/embedded/pdf/STM32F4DISCOVERY.pdf
[Simple Program ─ Blink in Lecture 04]: http://md.nc.es.ncku.edu.tw/wE1aZJ7OTUOKUBOYB_YbkQ#Simple-Program-%E2%94%80-Blink


-------------------------------

###### tags: `ES EMBEDDED COURSE Handout` `STM32` `ARM`